<?php
// $Id$

/**
 * Implements field hook_field_info().
 */
function computed_field_field_info() {
  return array(
    'computed' => array(
      'label' => t('Computed'),
      'description' => t('Create field data via PHP code.'),
      // @TODO
      'settings' => array('code', 'display_format', 'store', 'data_type', 'data_length', 'data_not_NULL', 'data_default', 'data_sortable'),
    ),
  );
}

/**
 * Implements of hook_field_settings_form().
 */
function computed_field_field_settings_form($field, $instance, $has_data) {
  $form = array();
  $compute_func = 'computed_field_'. $field['field_name'] .'_compute';
  $display_func = 'computed_field_'. $field['field_name'] .'_display';
  $settings = $field['settings'];
  // these next 3 have been moved from widget to field, so they copy default values from widget
  $form['code'] = array(
    '#type' => 'textarea',
    '#rows' => 15,
    '#title' => t('Computed Code'),
    '#description' => t('The variables available to your code are: ') .'<code>&amp;$node, $field, and &amp;$entity_field</code>'. t('. To set the value of the field, set ') .'<code>$entity_field[0][\'value\']</code>'. t('. Here\'s a simple example which sets the computed field\'s value to the value of the sum of the number fields field_a and field_b: ') .'<code>$entity_field[0][\'value\'] = $node->field_a[0][\'value\'] + $node->field_b[0][\'value\'];</code>. '. t('Alternately, this code can be supplied by your own custom function named @compute_func().', array('@compute_func' => $compute_func)),
    '#default_value' => !empty($settings['code']) ? $settings['code'] : '$entity_field[0][\'value\'] = "";',
    '#access' => !function_exists($compute_func),
  );
  if (function_exists($compute_func)) {
    $form['compute_func'] = array(
    '#type' => 'item',
    '#value' => t('This field is computed using @compute_func().', array('@compute_func' => $compute_func)),
    );
  }
  $form['display_format'] = array(
    '#type' => 'textarea',
    '#title' => t('Display Format'),
    '#description' => t('This code should assign a string to the $display variable, which will be printed as the value of the field. The stored value of the field is in $entity_field_item[\'value\'].  Note: this code has no effect if you use the "Computed Value" formatter option. Alternately, this code can be supplied by your own custom function named @display_func().', array('@display_func' => $display_func)) ,
    '#default_value' => !empty($settings['display_format']) ? $settings['display_format'] : '$display = $entity_field_item[\'value\'];',
    '#access' => !function_exists($display_func),
  );
  if (function_exists($display_func)) {
    $form['display_func'] = array(
      '#type' => 'item',
      '#value' => t('This field is computed using @display_func().', array('@display_func' => $display_func)),
      );
  }
  $form['store'] = array(
    '#type' => 'checkbox',
    '#title' => t('Store using the database settings below'),
    '#default_value' => is_numeric($settings['store']) ? $settings['store'] : 1 ,
  );
  $form['database'] = array('#type' => 'fieldset', '#title' => t('Database Storage Settings'));
  $form['database']['data_type'] = array(
    '#type' => 'radios',
    '#title' => t('Data Type'),
    '#description' => t('The SQL datatype to store this field in.'),
    '#default_value' => !empty($settings['data_type']) ? $settings['data_type'] : 'varchar',
    '#options' => array('int' => 'int', 'float' => 'float', 'varchar' => 'varchar', 'text' => 'text', 'longtext' => 'longtext'),
    '#required' => FALSE,
  );
  $form['database']['data_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Data Length'),
    '#default_value' => !empty($settings['data_length']) ? $settings['data_length'] : NULL,
    '#required' => FALSE,
  );
  $form['database']['data_default'] = array(
    '#type' => 'textfield',
    '#title' => t('Default Value'),
    '#default_value' => $settings['data_default'],
    '#required' => FALSE,
  );
  $form['database']['data_not_NULL'] = array(
    '#type' => 'checkbox',
    '#title' => t('Not NULL'),
    '#default_value' => is_numeric($settings['data_not_NULL']) ? $settings['data_not_NULL'] : FALSE,
  );
  $form['database']['data_sortable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Sortable'),
    '#default_value' => is_numeric($settings['data_sortable']) ? $settings['data_sortable'] : TRUE,
  );
  return $form;
}

/**
 * Implements of hook_field_settings_validate().
 */
  function computed_field_field_settings_validate($field, $instance, $has_data) {
  $settings = $field['settings'];
  if ($settings['store']) {
    if (empty($settings['data_type'])) {
      form_set_error('data_type', t('To store this field in the database, please specify a data type.'));
    }
    if (!($settings['data_type'] == 'text' || $settings['data_type'] == 'longtext') && empty($settings['data_length'])) {
      form_set_error('data_length', t('To store this field in the database, please specify the data length.'));
    }
  }
}

/**
 * Implements of hook_field_schema().
 */
function computed_field_field_schema($field) {
  if ($field['type'] == 'computed') {
    $settings = $field['settings'];
    if ($settings['store']) {
      $columns = array('value' => array());
      if ($settings['data_type'] == 'longtext') {
        $columns['value']['type'] = 'text';
        $columns['value']['size'] = 'big';
      }
      else {
        $columns['value']['type'] = isset($settings['data_type']) ? $settings['data_type'] : 'varchar';
      }
      // text and longtext should not have a length, so we ignore it
      if (!($field['data_type'] == 'text' || $settings['data_type'] == 'longtext')) {
        $columns['value']['length'] = isset($settings['data_length']) ? $settings['data_length'] : 32;
      }
      $columns['value']['not NULL'] = isset($settings['data_not_NULL']) ? $settings['data_not_NULL'] : TRUE;
      $columns['value']['sortable'] = isset($settings['data_sortable']) ? $settings['data_sortable'] : FALSE;
      if ($field['data_default'] != '')  {
        $columns['value']['default'] = $settings['data_default'];
      }
    }
  }
  return array(
    'columns' => $columns,
  );
}

/**
 * Implements of hook_field_settings_filters().
 */
function computed_field_field_settings_filters($field) {
  return array(
    'default' => array(
      'name' => t('Default'),
      'operator' => 'views_handler_operator_gtlt',
    ),
  );
}

/**
 * Implements of hook_field_settings_callbacks().
 */
function computed_field_field_settings_callbacks($field) {
  return array(
    'view' => FIELD_BEHAVIOR_CUSTOM,
  );
}

/**
 * Implements of hook_field_settings_views_data().
 */
function computed_field_field_settings_views_data($field) {
  $allowed_values = content_allowed_values($field);
  if (count($allowed_values)) {
    $table_alias = _field_sql_storage_tablename($field);

    // Swap the filter handler to the 'in' operator.
    // @TODO Wait for fieldapi integration into views to implement this.
    $data[$table_alias][$field['field_name'] .'_value']['filter']['handler'] = 'content_handler_filter_many_to_one';
    return $data;
  }
}

function _computed_field_compute_value(&$node, $field, &$entity_field) {
  $settings = $field['settings'];
  // Allow the value to be computed from code not stored in DB
  $compute_func = 'computed_field_'. $field['field_name'] .'_compute';
  if (function_exists($compute_func)) {
    $compute_func($node, $field, $entity_field);
  }
  else {
    if (isset($settings['code'])) {
      eval($settings['code']);
    }
  }
}

/**
 * Implements field hook_field_load().
 */
function computed_field_field_load($node, $field, &$entity_field, $teaser, $page) {
  $settings = $field['settings'];
  // compute field on load if it isn't stored in the database
  if (!$settings['store']) {
    _computed_field_compute_value($node, $field, $entity_field);
    return array($field['field_name'] => $entity_field);
  }
}

/**
 * Implements field hook_field_sanitize().
 */
function computed_field_field_sanitize($node, $field, &$entity_field, $teaser, $page) {
  // compute field for node previews
  if ($node->build_mode == NODE_BUILD_PREVIEW) {
    _computed_field_compute_value($node, $field, $entity_field);
  }
}

/**
 * Implements field hook_field_view().
 */
function computed_field_field_view($node, $field, &$entity_field, $teaser, $page) {
  $items = array();
  foreach ($entity_field as $delta => $item) {
    $items[$delta]['view'] = content_format($field, $item, 'default', $node);
  }
  return theme('field', $node, $field, $items, $teaser, $page);
}

/**
 * Implements field hook_field_insert().
 */
function computed_field_field_insert($node, $field, &$entity_field, $teaser, $page) {
  _computed_field_compute_value($node, $field, $entity_field);
}

/**
 * Implements field hook_field_update().
 */
function computed_field_field_update($node, $field, &$entity_field, $teaser, $page) {
  _computed_field_compute_value($node, $field, $entity_field);
}

/**
 * Implements field hook_field_widget_info().
 */
function computed_field_field_widget_info() {
  return array(
    'computed' => array(
      'label' => t('Computed'),
      'field types' => array('computed'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Implements field hook_field_widget_form().
 */
function computed_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $elements = array();
  foreach($items as $delta => $item) {
    $elements[$delta]['value'] = array (
      '#type' => 'value',
      '#tree' => TRUE,
      '#default_value' => isset($item['value']) ? $item['value'] : NULL,
    );
  }
  return $elements;
}

/**
 * Implements hook_theme().
 */
function computed_field_theme() {
  return array(
    'computed_field_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'computed_field_formatter_plain' => array(
      'arguments' => array('element' => NULL),
    ),
    'computed_field_formatter_markup' => array(
      'arguments' => array('element' => NULL),
    ),
    'computed_field_formatter_computed_value' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function computed_field_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('Raw text'),
      'field types' => array('computed'),
    ),
    'plain' => array(
      'label' => t('Plain text'),
      'field types' => array('computed'),
    ),
    'markup' => array(
      'label' => t('Markup'),
      'field types' => array('computed'),
    ),
    'computed_value' => array(
      'label' => t('Computed Value'),
      'field types' => array('computed'),
    ),
  );
}

/**
 * Theme function for 'default' text field formatter.
 */
function theme_computed_field_formatter_default($element) {
  $field = field_info_fields($element['#field_name']);
  // For "some" backwards compatibility
  $entity_field_item['value'] = $element['#item']['value'];

  // Allow the value to be formated from code not stored in DB
  $display_func = 'computed_field_'. $field['field_name'] .'_display';
  if (function_exists($display_func)) {
    $display = $display_func($field, $element);
  }
  else {
    eval($field['display_format']);
  }
  return $display;
}

/**
 * Theme function for 'plain' text field formatter.
 */
function theme_computed_field_formatter_plain($element) {
  $field = field_info_fields($element['#field_name']);
  // For "some" backwards compatibility
  $entity_field_item['value'] = $element['#item']['value'];

  // Allow the value to be formated from code not stored in DB
  $display_func = 'computed_field_'. $field['field_name'] .'_display';
  if (function_exists($display_func)) {
    $display = $display_func($field, $element);
  }
  else {
    eval($field['display_format']);
  }
  return check_plain($display);
}

/**
 * Theme function for 'markup' text field formatter.
 */
function theme_computed_field_formatter_markup($element) {
  $field = field_info_fields($element['#field_name']);
  // For "some" backwards compatibility
  $entity_field_item['value'] = $element['#item']['value'];

  // Allow the value to be formated from code not stored in DB
  $display_func = 'computed_field_'. $field['field_name'] .'_display';
  if (function_exists($display_func)) {
    $display = $display_func($field, $element);
  }
  else {
    eval($field['display_format']);
  }
  return check_markup($display);
}

/**
 * Theme function for 'computed_value' text field formatter.
 */
function theme_computed_field_formatter_computed_value($element) {
  return $element['#item']['value'];
}

/**
 * Implements field hook_field_is_empty().
 */
function computed_field_field_is_empty() {
  return FALSE;
}

/**
 * Implements hook_token_list().
 */
function computed_field_token_list($type = 'all') {
  if ($type == 'field' || $type == 'all') {
    $tokens = array();

    $tokens['computed_field']['raw']       = t("Raw, unfiltered text.");
    $tokens['computed_field']['formatted'] = t("Formatted and filtered text.");

    return $tokens;
  }
}

/**
 * Implements hook_token_values().
 */
function computed_field_token_values($type, $object = NULL, $options = array()) {
  if ($type == 'field') {
    $item = $object[0];
    $tokens['raw']  = $item['value'];
    $tokens['formatted'] = $item['view'];
    return $tokens;
  }
}
